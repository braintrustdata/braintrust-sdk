# generated by datamodel-codegen:
#   filename:  btql_schema.json
#   timestamp: 2025-10-15T02:38:17+00:00

from __future__ import annotations

from typing import Literal, TypeAlias, TypedDict

from typing_extensions import NotRequired

ArithmeticOp = Literal['add', 'sub', 'mul', 'div', 'mod']


BooleanLiteral = bool


BooleanOp = Literal['and', 'or']


ComparisonOp = Literal['eq', 'is', 'ne', 'lt', 'le', 'gt', 'ge', 'ilike', 'like', 'match', 'in']


class CountSample(TypedDict):
    type: Literal['count']
    value: int


DatetimeLiteral = str


IdentPiece = str | float


IntegerLiteral = int


IntervalUnit = Literal['year', 'month', 'day', 'hour', 'minute', 'second', 'millisecond', 'microsecond']


NullLiteral = None


NumberLiteral = float


class Pos(TypedDict):
    line: float
    col: float


class RateSample(TypedDict):
    type: Literal['rate']
    value: float


class Sample(TypedDict):
    method: RateSample | CountSample
    seed: NotRequired[int | None]


Shape = Literal['spans', 'traces', 'summary']


SortDirection = Literal['asc', 'desc']


StringLiteral = str


UnaryArithmeticOp = Literal['neg']


UnaryOp = Literal['not', 'isnull', 'isnotnull']


class Loc(TypedDict):
    start: Pos
    end: Pos


LocModel = Loc | None


class BtqlSnippet(TypedDict):
    btql: str
    op: NotRequired[str | None]
    loc: NotRequired[Loc | None]


class Ident(TypedDict):
    op: Literal['ident']
    name: list[IdentPiece]
    loc: NotRequired[LocModel]


class IntervalLiteral(TypedDict):
    op: Literal['interval']
    value: int
    unit: IntervalUnit
    loc: NotRequired[LocModel]


ParsedQuery = TypedDict(
    'Model',
    {
        'dimensions': NotRequired['list[AliasExpr] | None'],
        'pivot': NotRequired['list[AliasExpr] | None'],
        'unpivot': NotRequired['list[UnpivotAliasExpr] | None'],
        'measures': NotRequired['list[AliasExpr] | None'],
        'select': NotRequired['list[AliasExpr | Star] | None'],
        'infer': NotRequired['list[Ident | Star] | None'],
        'filter': NotRequired['Expr | None'],
        'from': NotRequired['Ident | FromFunction | None'],
        'sort': NotRequired['list[SortExpr] | None'],
        'limit': NotRequired['int | None'],
        'cursor': NotRequired['str | None'],
        'comparison_key': NotRequired['Expr | None'],
        'weighted_scores': NotRequired['list[AliasExpr] | None'],
        'custom_columns': NotRequired['list[AliasExpr] | None'],
        'preview_length': NotRequired['int | None'],
        'inference_budget': NotRequired['int | None'],
        'sample': NotRequired['Sample | None'],
    },
)


class AliasExpr(TypedDict):
    expr: Expr
    alias: str


class ArithmeticExpr(TypedDict):
    op: Literal['add', 'sub', 'mul', 'div', 'mod']
    left: Expr
    right: Expr
    loc: NotRequired[Loc | None]


ArrayLiteral: TypeAlias = "list[LiteralValue]"


class BooleanExpr(TypedDict):
    op: Literal['and', 'or']
    left: NotRequired[Expr]
    right: NotRequired[Expr]
    children: NotRequired[list[Expr]]
    loc: NotRequired[LocModel]


class ComparisonExpr(TypedDict):
    op: Literal['eq', 'is', 'ne', 'lt', 'le', 'gt', 'ge', 'ilike', 'like', 'match', 'in']
    left: Expr
    right: Expr
    loc: NotRequired[LocModel]


Expr: TypeAlias = "LiteralModel | IntervalLiteral | Ident | Star | Function | ComparisonExpr | IncludesExpr | BooleanExpr | TernaryExpr | UnaryArithmeticExpr | UnaryExpr | ArithmeticExpr | BtqlSnippet"



class Function(TypedDict):
    op: Literal['function']
    name: Ident
    args: list[Expr]
    loc: NotRequired[LocModel]


class IncludesExpr(TypedDict):
    op: Literal['includes']
    haystack: Expr
    needle: Expr
    loc: NotRequired[LocModel]


class LiteralModel(TypedDict):
    op: Literal['literal']
    value: LiteralValue
    loc: NotRequired[LocModel]


LiteralValue: TypeAlias = "NullLiteral | BooleanLiteral | IntegerLiteral | NumberLiteral | StringLiteral | DatetimeLiteral | ArrayLiteral | ObjectLiteral"



ObjectLiteral: TypeAlias = "dict[str, LiteralValue]"


class SortExpr(TypedDict):
    expr: Expr
    dir: SortDirection
    loc: NotRequired[Loc | None]


class Star(TypedDict):
    op: Literal['star']
    replace: NotRequired[dict[str, Expr]]
    loc: NotRequired[LocModel]


class TernaryCond(TypedDict):
    cond: Expr
    then: Expr


TernaryExpr = TypedDict(
    'TernaryExpr',
    {
        'op': Literal['if'],
        'conds': list[TernaryCond],
        'else': Expr,
        'loc': NotRequired['LocModel'],
    },
)


class UnaryArithmeticExpr(TypedDict):
    op: Literal['neg']
    expr: Expr
    loc: NotRequired[LocModel]


class UnaryExpr(TypedDict):
    op: Literal['not', 'isnull', 'isnotnull']
    expr: Expr
    loc: NotRequired[LocModel]


class UnpivotAliasExpr(TypedDict):
    expr: Expr
    alias: str | list[str]


class FromFunction(Function):
    shape: NotRequired[Shape | None]
